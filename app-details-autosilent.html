<!DOCTYPE html>
<html class="dark" lang="en"><head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Auto Silent Details</title>
<link href="https://fonts.googleapis.com" rel="preconnect"/>
<link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect"/>
<link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;700&display=swap" rel="stylesheet"/>
<script src="https://cdn.tailwindcss.com?plugins=forms,container-queries"></script>
<script>
      tailwind.config = {
        darkMode: "class",
        theme: {
          extend: {
            colors: {
              primary: "#1919e6",
              "background-light": "#f6f6f8",
              "background-dark": "#111121",
            },
            fontFamily: {
              display: ["Space Grotesk"],
            },
            borderRadius: {
              DEFAULT: "0.25rem",
              lg: "0.5rem",
              xl: "0.75rem",
              full: "9999px",
            },
          },
        },
      };
    </script>
<link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined" rel="stylesheet"/>
<style>
    body {
      min-height: max(884px, 100dvh);
    }
  </style>
<script>
document.addEventListener('DOMContentLoaded', function() {
  const titleElement = document.getElementById('app-title');
  const text = 'Auto Silent Details';
  let index = 0;
  const typingSpeed = 75;

  function typeWriter() {
    if (index < text.length) {
      titleElement.textContent += text.charAt(index);
      index++;
      setTimeout(typeWriter, typingSpeed);
    } else {
      // Add blinking cursor
      const cursor = document.createElement('span');
      cursor.textContent = '|';
      cursor.style.animation = 'blink 1s infinite';
      titleElement.appendChild(cursor);
    }
  }

  // Start typing after a short delay
  setTimeout(typeWriter, 500);
});

// Ballpit animation
document.addEventListener('DOMContentLoaded', function() {
  const canvas = document.getElementById('ballpit-canvas');
  const ctx = canvas.getContext('2d');
  let balls = [];
  const ballCount = 200;
  const gravity = 0.7;
  const friction = 0.8;
  const wallBounce = 0.95;

  function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }

  function createBalls() {
    balls = [];
    for (let i = 0; i < ballCount; i++) {
      balls.push({
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height,
        vx: (Math.random() - 0.5) * 2,
        vy: (Math.random() - 0.5) * 2,
        radius: Math.random() * 5 + 2,
        color: `hsl(${Math.random() * 360}, 70%, 50%)`
      });
    }
  }

  function updateBalls() {
    balls.forEach(ball => {
      ball.vy += gravity;
      ball.vx *= friction;
      ball.vy *= friction;

      ball.x += ball.vx;
      ball.y += ball.vy;

      // Bounce off walls
      if (ball.x - ball.radius < 0 || ball.x + ball.radius > canvas.width) {
        ball.vx *= -wallBounce;
        ball.x = Math.max(ball.radius, Math.min(canvas.width - ball.radius, ball.x));
      }
      if (ball.y - ball.radius < 0 || ball.y + ball.radius > canvas.height) {
        ball.vy *= -wallBounce;
        ball.y = Math.max(ball.radius, Math.min(canvas.height - ball.radius, ball.y));
      }

      // Ball collisions
      balls.forEach(otherBall => {
        if (ball !== otherBall) {
          const dx = otherBall.x - ball.x;
          const dy = otherBall.y - ball.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          const minDistance = ball.radius + otherBall.radius;

          if (distance < minDistance) {
            const angle = Math.atan2(dy, dx);
            const targetX = ball.x + Math.cos(angle) * minDistance;
            const targetY = ball.y + Math.sin(angle) * minDistance;
            const ax = (targetX - otherBall.x) * 0.05;
            const ay = (targetY - otherBall.y) * 0.05;

            ball.vx -= ax;
            ball.vy -= ay;
            otherBall.vx += ax;
            otherBall.vy += ay;
          }
        }
      });
    });
  }

  function drawBalls() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    balls.forEach(ball => {
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
      ctx.fillStyle = ball.color;
      ctx.fill();
    });
  }

  function animate() {
    updateBalls();
    drawBalls();
    requestAnimationFrame(animate);
  }

  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();
  createBalls();
  animate();
});
</script>
<style>
@keyframes blink {
  0%, 50% { opacity: 1; }
  51%, 100% { opacity: 0; }
}

.shiny-text {
  color: #b5b5b5a4 !important;
  background: linear-gradient(
    120deg,
    rgba(255, 255, 255, 0) 40%,
    rgba(255, 255, 255, 0.8) 50%,
    rgba(255, 255, 255, 0) 60%
  );
  background-size: 200% 100%;
  -webkit-background-clip: text;
  background-clip: text;
  display: inline-block;
  animation: shine 3s linear infinite;
}

@keyframes shine {
  0% {
    background-position: 100%;
  }
  100% {
    background-position: -100%;
  }
}

.gradient-text {
  background: linear-gradient(to right, #40ffaa, #4079ff, #40ffaa, #4079ff, #40ffaa);
  background-size: 300% 100%;
  background-clip: text;
  -webkit-background-clip: text;
  color: transparent;
  animation: gradient 8s linear infinite;
}

@keyframes gradient {
  0% {
    background-position: 0% 50%;
  }
  50% {
    background-position: 100% 50%;
  }
  100% {
    background-position: 0% 50%;
  }
}
</style>
   </head>
<body class="bg-background-light dark:bg-background-dark font-display text-gray-800 dark:text-gray-200">
